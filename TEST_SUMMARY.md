# 테스트 파일별 describe/it 타이틀 원문

## components

### RecurringEventDialog.spec.tsx
- `describe('RecurringEventDialog', () => {`
  - `describe('수정 모드', () => {`
    - `it('반복 일정 다이얼로그가 올바르게 렌더링된다', () => {`
    - `it('수정 모드에서 예/아니오 버튼이 표시된다', () => {`
    - `it('수정 모드에서 예 버튼 클릭 시 editSingleOnly=true로 onConfirm이 호출된다', async () => {`
    - `it('수정 모드에서 아니오 버튼 클릭 시 editSingleOnly=false로 onConfirm이 호출된다', async () => {`
    - `it('수정 모드에서 취소 버튼 클릭 시 onClose가 호출된다', async () => {`
    - `it('다이얼로그가 열려있지 않으면 렌더링되지 않는다', () => {`
  - `describe('삭제 모드 (P0 테스트)', () => {`
    - `it('삭제 모드에서 다이얼로그가 올바르게 렌더링된다', () => {`
    - `it('삭제 모드에서 예/아니오 버튼이 표시된다', () => {`
    - `it('삭제 모드에서 예 버튼 클릭 시 deleteSingleOnly=true로 onConfirm이 호출된다', async () => {`
    - `it('삭제 모드에서 아니오 버튼 클릭 시 deleteSingleOnly=false로 onConfirm이 호출된다', async () => {`
    - `it('삭제 모드에서 취소 버튼 클릭 시 onClose가 호출된다', async () => {`
    - `it('삭제 모드에서 다이얼로그가 열려있지 않으면 렌더링되지 않는다', () => {`

---

## hooks

### easy.useCalendarView.spec.ts
- `describe('초기 상태', () => {`
  - `it('view는 "month"이어야 한다', () => {`
  - `it('currentDate는 오늘 날짜인 "2025-10-01"이어야 한다', () => {`
  - `it('holidays는 10월 휴일인 개천절, 한글날, 추석이 지정되어 있어야 한다', () => {`
- `it("view를 'week'으로 변경 시 적절하게 반영된다", () => {`
- `it("주간 뷰에서 다음으로 navigate시 7일 후 '2025-10-08' 날짜로 지정이 된다", () => {`
- `it("주간 뷰에서 이전으로 navigate시 7일 후 '2025-09-24' 날짜로 지정이 된다", () => {`
- `it("월간 뷰에서 다음으로 navigate시 한 달 후 '2025-11-01' 날짜여야 한다", () => {`
- `it("월간 뷰에서 이전으로 navigate시 한 달 전 '2025-09-01' 날짜여야 한다", () => {`
- `it("currentDate가 '2025-03-01' 변경되면 3월 휴일 '삼일절'로 업데이트되어야 한다", async () => {`

### easy.useSearch.spec.ts
- `it('검색어가 비어있을 때 모든 이벤트를 반환해야 한다', () => {`
- `it('검색어에 맞는 이벤트만 필터링해야 한다', () => {`
- `it('검색어가 제목, 설명, 위치 중 하나라도 일치하면 해당 이벤트를 반환해야 한다', () => {`
- `it('현재 뷰(주간/월간)에 해당하는 이벤트만 반환해야 한다', () => {`
- `it("검색어를 '회의'에서 '점심'으로 변경하면 필터링된 결과가 즉시 업데이트되어야 한다", () => {`

### medium.useEventOperations.spec.ts
- `it('저장되어있는 초기 이벤트 데이터를 적절하게 불러온다', async () => {`
- `it('정의된 이벤트 정보를 기준으로 적절하게 저장이 된다', async () => {`
- `it("새로 정의된 'title', 'endTime' 기준으로 적절하게 일정이 업데이트 된다", async () => {`
- `it('존재하는 이벤트 삭제 시 에러없이 아이템이 삭제된다.', async () => {`
- `it("이벤트 로딩 실패 시 '이벤트 로딩 실패'라는 텍스트와 함께 에러 토스트가 표시되어야 한다", async () => {`
- `it("존재하지 않는 이벤트 수정 시 '일정 저장 실패'라는 토스트가 노출되며 에러 처리가 되어야 한다", async () => {`
- `it("네트워크 오류 시 '일정 삭제 실패'라는 텍스트가 노출되며 이벤트 삭제가 실패해야 한다", async () => {`

### medium.useNotifications.spec.ts
- `it('초기 상태에서는 알림이 없어야 한다', () => {`
- `it('지정된 시간이 된 경우 알림이 새롭게 생성되어 추가된다', () => {`
- `it('index를 기준으로 알림을 적절하게 제거할 수 있다', () => {`
- `it('이미 알림이 발생한 이벤트에 대해서는 중복 알림이 발생하지 않아야 한다', () => {`

### useRecurringEventOperations.spec.ts
- `describe('useRecurringEventOperations', () => {`
  - `it('예(단일 수정)를 선택하면 해당 일정만 업데이트하고 반복을 제거한다', async () => {`
  - `it('아니오(전체 수정)를 선택하면 모든 반복 일정을 업데이트한다', async () => {`
  - `it('반복 일정이 아닌 일정을 편집하는 경우 일반적인 업데이트를 수행한다', async () => {`
  - `it('관련 반복 일정을 올바르게 찾는다', () => {`
  - `it('반복 일정이 없는 경우 빈 배열을 반환한다', () => {`
  - `it('단일 반복 일정만 있는 경우 빈 배열을 반환한다', () => {`
  - `describe('반복 일정 삭제 기능 (P1 테스트)', () => {`
    - `it('예(단일 삭제)를 선택하면 해당 일정만 삭제한다', async () => {`
    - `it('아니오(시리즈 삭제)를 선택하면 모든 관련 반복 일정을 삭제한다', async () => {`
    - `it('반복 일정이 아닌 일정을 삭제하는 경우 일반적인 삭제를 수행한다', async () => {`
    - `it('삭제할 일정이 존재하지 않는 경우 에러 없이 처리한다', async () => {`
    - `it('네트워크 오류 시에도 updateEvents가 호출된다', async () => {`
    - `it('서버에서 404 응답을 받아도 updateEvents가 호출된다', async () => {`
    - `it('단일 반복 일정의 경우 일반 삭제로 처리된다', async () => {`

---

## unit

### easy.dateUtils.spec.ts
- `describe('getDaysInMonth', () => {`
  - `it('1월은 31일 수를 반환한다', () => {`
  - `it('4월은 30일 일수를 반환한다', () => {`
  - `it('윤년의 2월에 대해 29일을 반환한다', () => {`
  - `it('평년의 2월에 대해 28일을 반환한다', () => {`
  - `it('유효하지 않은 월에 대해 적절히 처리한다', () => {`
- `describe('getWeekDates', () => {`
  - `it('주중의 날짜(수요일)에 대해 올바른 주의 날짜들을 반환한다', () => {`
  - `it('주의 시작(월요일)에 대해 올바른 주의 날짜들을 반환한다', () => {`
  - `it('주의 끝(일요일)에 대해 올바른 주의 날짜들을 반환한다', () => {`
  - `it('연도를 넘어가는 주의 날짜를 정확히 처리한다 (연말)', () => {`
  - `it('연도를 넘어가는 주의 날짜를 정확히 처리한다 (연초)', () => {`
  - `it('윤년의 2월 29일을 포함한 주를 올바르게 처리한다', () => {`
  - `it('월의 마지막 날짜를 포함한 주를 올바르게 처리한다', () => {`
- `describe('getWeeksAtMonth', () => {`
  - `it('2025년 7월 1일의 올바른 주 정보를 반환해야 한다', () => {`
- `describe('getEventsForDay', () => {`
  - `it('특정 날짜(1일)에 해당하는 이벤트만 정확히 반환한다', () => {`
  - `it('해당 날짜에 이벤트가 없을 경우 빈 배열을 반환한다', () => {`
  - `it('날짜가 0일 경우 빈 배열을 반환한다', () => {`
  - `it('날짜가 32일 이상인 경우 빈 배열을 반환한다', () => {`
- `describe('formatWeek', () => {`
  - `it('월의 중간 날짜에 대해 올바른 주 정보를 반환한다', () => {`
  - `it('월의 첫 주에 대해 올바른 주 정보를 반환한다', () => {`
  - `it('월의 마지막 주에 대해 올바른 주 정보를 반환한다', () => {`
  - `it('연도가 바뀌는 주에 대해 올바른 주 정보를 반환한다', () => {`
  - `it('윤년 2월의 마지막 주에 대해 올바른 주 정보를 반환한다', () => {`
  - `it('평년 2월의 마지막 주에 대해 올바른 주 정보를 반환한다', () => {`
- `describe('formatMonth', () => {`
  - `it("2025년 7월 10일을 '2025년 7월'로 반환한다", () => {`
- `describe('isDateInRange', () => {`
  - `it('범위 내의 날짜 2025-07-10에 대해 true를 반환한다', () => {`
  - `it('범위의 시작일 2025-07-01에 대해 true를 반환한다', () => {`
  - `it('범위의 종료일 2025-07-31에 대해 true를 반환한다', () => {`
  - `it('범위 이전의 날짜 2025-06-30에 대해 false를 반환한다', () => {`
  - `it('범위 이후의 날짜 2025-08-01에 대해 false를 반환한다', () => {`
  - `it('시작일이 종료일보다 늦은 경우 모든 날짜에 대해 false를 반환한다', () => {`
- `describe('fillZero', () => {`
  - `it("5를 2자리로 변환하면 '05'를 반환한다", () => {`
  - `it("10을 2자리로 변환하면 '10'을 반환한다", () => {`
  - `it("3을 3자리로 변환하면 '003'을 반환한다", () => {`
  - `it("100을 2자리로 변환하면 '100'을 반환한다", () => {`
  - `it("0을 2자리로 변환하면 '00'을 반환한다", () => {`
  - `it("1을 5자리로 변환하면 '00001'을 반환한다", () => {`
  - `it("소수점이 있는 3.14를 5자리로 변환하면 '03.14'를 반환한다", () => {`
  - `it('size 파라미터를 생략하면 기본값 2를 사용한다', () => {`
  - `it('value가 지정된 size보다 큰 자릿수를 가지면 원래 값을 그대로 반환한다', () => {`
- `describe('formatDate', () => {`
  - `it('날짜를 YYYY-MM-DD 형식으로 포맷팅한다', () => {`
  - `it('day 파라미터가 제공되면 해당 일자로 포맷팅한다', () => {`
  - `it('월이 한 자리 수일 때 앞에 0을 붙여 포맷팅한다', () => {`
  - `it('일이 한 자리 수일 때 앞에 0을 붙여 포맷팅한다', () => {`

### easy.eventOverlap.spec.ts
- `describe('parseDateTime', () => {`
  - `it('2025-07-01 14:30을 정확한 Date 객체로 변환한다', () => {`
  - `it('잘못된 날짜 형식에 대해 Invalid Date를 반환한다', () => {`
  - `it('잘못된 시간 형식에 대해 Invalid Date를 반환한다', () => {`
  - `it('날짜 문자열이 비어있을 때 Invalid Date를 반환한다', () => {`
- `describe('convertEventToDateRange', () => {`
  - `it('일반적인 이벤트를 올바른 시작 및 종료 시간을 가진 객체로 변환한다', () => {`
  - `it('잘못된 날짜 형식의 이벤트에 대해 Invalid Date를 반환한다', () => {`
  - `it('잘못된 시간 형식의 이벤트에 대해 Invalid Date를 반환한다', () => {`
- `describe('isOverlapping', () => {`
  - `it('두 이벤트가 겹치는 경우 true를 반환한다', () => {`
  - `it('두 이벤트가 겹치지 않는 경우 false를 반환한다', () => {`
- `describe('findOverlappingEvents', () => {`
  - `it('새 이벤트와 겹치는 모든 이벤트를 반환한다', () => {`
  - `it('겹치는 이벤트가 없으면 빈 배열을 반환한다', () => {`

### easy.eventUtils.spec.ts
- `describe('getFilteredEvents', () => {`
  - `it("검색어 '이벤트 2'에 맞는 이벤트만 반환한다", () => {`
  - `it('주간 뷰에서 2025-07-01 주의 이벤트만 반환한다', () => {`
  - `it('월간 뷰에서 2025년 7월의 모든 이벤트를 반환한다', () => {`
  - `it("검색어 '이벤트'와 주간 뷰 필터링을 동시에 적용한다", () => {`
  - `it('검색어가 없을 때 모든 이벤트를 반환한다', () => {`
  - `it('검색어가 대소문자를 구분하지 않고 작동한다', () => {`
  - `it('월의 경계에 있는 이벤트를 올바르게 필터링한다', () => {`
  - `it('빈 이벤트 리스트에 대해 빈 배열을 반환한다', () => {`

### easy.fetchHolidays.spec.ts
- `describe('fetchHolidays', () => {`
  - `it('주어진 월의 공휴일만 반환한다', () => {`
  - `it('공휴일이 없는 월에 대해 빈 객체를 반환한다', () => {`
  - `it('여러 공휴일이 있는 월에 대해 모든 공휴일을 반환한다', () => {`

### easy.notificationUtils.spec.ts
- `describe('getUpcomingEvents', () => {`
  - `it('알림 시간이 정확히 도래한 이벤트를 반환한다', () => {`
  - `it('이미 알림이 간 이벤트는 제외한다', () => {`
  - `it('알림 시간이 아직 도래하지 않은 이벤트는 반환하지 않는다', () => {`
  - `it('알림 시간이 지난 이벤트는 반환하지 않는다', () => {`
- `describe('createNotificationMessage', () => {`
  - `it('올바른 알림 메시지를 생성해야 한다', () => {`

### easy.timeValidation.spec.ts
- `describe('getTimeErrorMessage >', () => {`
  - `it('시작 시간이 종료 시간보다 늦을 때 에러 메시지를 반환한다', () => {`
  - `it('시작 시간과 종료 시간이 같을 때 에러 메시지를 반환한다', () => {`
  - `it('시작 시간이 종료 시간보다 빠를 때 null을 반환한다', () => {`
  - `it('시작 시간이 비어있을 때 null을 반환한다', () => {`
  - `it('종료 시간이 비어있을 때 null을 반환한다', () => {`
  - `it('시작 시간과 종료 시간이 모두 비어있을 때 null을 반환한다', () => {`

### generateRepeatEvents.spec.ts
- `describe('제약 조건', () => {`
  - `it('반복 없는 이벤트는 단일 이벤트로 배열에 담겨 반환된다', () => {`
- `describe('일간 반복 테스트', () => {`
  - `it("'2024-01-01'부터 '2024-01-03'까지 매일 반복하는 경우 '2024-01-01', '2024-01-02', '2024-01-03'이 된다", () => {`
  - `it("'2024-01-01'부터 '2024-01-05'까지 2일 간격으로 반복하는 경우 '2024-01-01', '2024-01-03', '2024-01-05'가 된다", () => {`
- `describe('주간 반복 테스트', () => {`
  - `it("'2024-01-01'를 기준으로 '2024-01-15'까지 매주 간격으로 생성하는 경우 '2024-01-01', '2024-01-08', '2024-01-15'가 된다", () => {`
  - `it("'2024-01-01'를 기준으로 2주 간격으로 생성하는 경우 '2024-01-01', '2024-01-15', '2024-01-29'가 된다", () => {`
- `describe('월간 반복 테스트', () => {`
  - `it('2024-01-15를 기준으로 2024-03-15까지 매월 반복되는 이벤트의 날짜는 "2024-01-15", "2024-02-15", "2024-03-25"이다', () => {`
  - `it('2024-01-15를 기준으로 2024-05-15까지 2달 반복되는 이벤트의 날짜는 "2024-01-15", "2024-03-15", "2024-05-25"이다', () => {`
  - `it('24년 1월 31일을 기준으로 2024-04-30까지 매월 반복하는 경우 "2024-01-31", "2024-03-31"가 된다', () => {`
- `describe('연간 반복 테스트', () => {`
  - `it('매년 반복되는 이벤트를 정확히 생성해야 함', () => {`
  - `it('2년 간격으로 반복되는 이벤트를 정확히 생성해야 함', () => {`
  - `it('윤년 날짜 처리를 정확히 해야 함', () => {`
- `it('interval이 0이면 단일 이벤트만 반환한다', () => {`

---

## integration

### recurringEventWorkflow.spec.tsx
- `describe('반복 일정 워크플로우 통합 테스트', () => {`
  - `it('반복 일정을 생성하고 편집 다이얼로그가 나타나는지 확인한다', async () => {`
  - `it('예를 선택하면 해당 일정만 단일 일정으로 변경된다', async () => {`
  - `it('아니오를 선택하면 모든 반복 일정이 변경된다', async () => {`
  - `describe('반복 일정 삭제 워크플로우 (P2 테스트)', () => {`
    - `it('반복 일정 삭제 시 삭제 다이얼로그가 나타난다', async () => {`
    - `it('삭제 다이얼로그에서 예를 선택하면 해당 일정만 삭제된다', async () => {`
    - `it('삭제 다이얼로그에서 아니오를 선택하면 모든 반복 일정이 삭제된다', async () => {`
    - `it('삭제 다이얼로그에서 취소를 선택하면 삭제가 취소된다', async () => {`

### medium.integration.spec.tsx
- `describe('일정 CRUD 및 기본 기능', () => {`
  - `it('입력한 새로운 일정 정보에 맞춰 모든 필드가 이벤트 리스트에 정확히 저장된다.', async () => {`
  - `it('기존 일정의 세부 정보를 수정하고 변경사항이 정확히 반영된다', async () => {`
  - `it('일정을 삭제하고 더 이상 조회되지 않는지 확인한다', async () => {`
- `describe('일정 뷰', () => {`
  - `it('주별 뷰를 선택 후 해당 주에 일정이 없으면, 일정이 표시되지 않는다.', async () => {`
  - `it('주별 뷰 선택 후 해당 일자에 일정이 존재한다면 해당 일정이 정확히 표시된다', async () => {`
  - `it('월별 뷰에 일정이 없으면, 일정이 표시되지 않아야 한다.', async () => {`
  - `it('월별 뷰에 일정이 정확히 표시되는지 확인한다', async () => {`
  - `it('달력에 1월 1일(신정)이 공휴일로 표시되는지 확인한다', async () => {`
- `describe('검색 기능', () => {`
  - `it('검색 결과가 없으면, "검색 결과가 없습니다."가 표시되어야 한다.', async () => {`
  - `it("'팀 회의'를 검색하면 해당 제목을 가진 일정이 리스트에 노출된다", async () => {`
  - `it('검색어를 지우면 모든 일정이 다시 표시되어야 한다', async () => {`
- `describe('일정 충돌', () => {`
  - `it('겹치는 시간에 새 일정을 추가할 때 경고가 표시된다', async () => {`
  - `it('기존 일정의 시간을 수정하여 충돌이 발생하면 경고가 노출된다', async () => {`
- `it('notificationTime을 10으로 하면 지정 시간 10분 전 알람 텍스트가 노출된다', async () => {`
- `it('입력한 새로운 반복 일정 정보에 맞춰 모든 필드가 이벤트 리스트에 정확히 저장된다.', async () => {`
- `it('새로 추가한 반복 일정을 수정하는 경우 반복 일정에 관한 표시가 사라진다', async () => {`
- `it('반복 일정을 수정하는 경우 반복 유형 관련 입력 폼이 사라진다', async () => {`
- `it('주별 뷰 선택 후 해당 주에 반복 일정이 존재한다면 해당 일정이 반복 일정 표시와 함께 정확히 표시된다', async () => {`
- `it('월간 뷰 선택 후 해당 주에 반복 일정이 존재한다면 해당 일정이 반복 일정 표시와 함께 정확히 표시된다', async () => {`

---

## edge-cases

### recurringEventEdgeCases.spec.tsx
- `describe('반복 일정 엣지 케이스', () => {`
  - `describe('RecurringEventDialog 엣지 케이스', () => {`
    - `it('이벤트가 null인 경우에도 안전하게 렌더링된다', () => {`
    - `it('반복 정보가 없는 이벤트에 대해서도 안전하게 렌더링된다', () => {`
    - `it('키보드 이벤트로도 버튼을 선택할 수 있다', async () => {`
    - `it('Escape 키로 다이얼로그를 닫을 수 있다', async () => {`
  - `describe('useRecurringEventOperations 엣지 케이스', () => {`
    - `it('빈 이벤트 배열에서도 안전하게 동작한다', async () => {`
    - `it('존재하지 않는 이벤트를 편집하려고 할 때 안전하게 처리한다', async () => {`
    - `it('반복 정보가 부분적으로 누락된 이벤트도 처리한다', () => {`
    - `it('같은 제목과 시간을 가진 다른 반복 일정 그룹을 구분한다', () => {`
    - `it('다양한 반복 유형을 올바르게 처리한다', () => {`
  - `describe('날짜/시간 경계 케이스', () => {`
    - `it('월 경계를 넘나드는 반복 일정을 올바르게 처리한다', () => {`
    - `it('윤년 2월 29일을 포함한 반복 일정을 처리한다', () => {`

---

## regression

### recurringEventRegression.spec.tsx
- `describe('반복 일정 회귀 테스트', () => {`
  - `describe('검색 기능 호환성', () => {`
    - `it('반복 일정도 검색 결과에 올바르게 포함된다', async () => {`
  - `describe('뷰 모드 호환성', () => {`
    - `it('주별 뷰에서 반복 일정이 올바르게 표시된다', async () => {`
    - `it('월별 뷰에서 반복 일정이 올바르게 표시된다', async () => {`
  - `describe('알림 기능 호환성', () => {`
    - `it('반복 일정의 각 인스턴스에 대해 개별 알림이 작동한다', async () => {`
  - `describe('충돌 감지 호환성', () => {`
    - `it('반복 일정 생성시 충돌을 감지하지 않는다', async () => {`

